#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet
from reportlab.platypus import Paragraph, Spacer, SimpleDocTemplate, PageBreak, Table, TableStyle
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape
from reportlab.lib.units import inch
from reportlab.lib.enums import TA_JUSTIFY, TA_LEFT, TA_CENTER
import pandas as pd
from collections import defaultdict
from datetime import datetime
import argparse


def get_unique_non_na_value(df, column_name):
    """Get the unique non-N/A value from a column, or return 'Unknown' if not found."""
    unique_values = df[column_name].dropna().unique()
    return unique_values[0] if len(unique_values) == 1 else "Multiple values" if len(unique_values) > 1 else "Unknown"

def generate_metadata_section(tsv_df, metadata_file=None):
    """Generates metadata text from the TSV file and optional metadata file."""
    styles = getSampleStyleSheet()
    
    # Create custom styles
    title_style = ParagraphStyle(
        'TitleStyle',
        parent=styles['Heading1'],
        fontSize=16,
        alignment=TA_CENTER,
        spaceAfter=12
    )
    heading_style = ParagraphStyle(
        'HeadingStyle',
        parent=styles['Heading2'],
        fontSize=12,
        spaceBefore=6,
        spaceAfter=6
    )
    normal_style = ParagraphStyle(
        'NormalStyle',
        parent=styles['Normal'],
        fontSize=10,
        spaceBefore=3,
        spaceAfter=3
    )

    # Get the lineage/clade, organism, reference accession, and reference database name
    lineage_clade = get_unique_non_na_value(tsv_df, 'clade')
    organism = get_unique_non_na_value(tsv_df, 'organism')
    ref_accession = get_unique_non_na_value(tsv_df, 'reference_accession')
    ref_db_name = get_unique_non_na_value(tsv_df, 'reference_database_name')

    report_date = datetime.today().strftime('%Y-%m-%d')

    if metadata_file:
        metadata_df = pd.read_csv(metadata_file, sep="\t", low_memory=False, compression='gzip')
        metadata_df['sample_collection_date'] = pd.to_datetime(
            metadata_df['sample_collection_date'], format='%Y-%m-%d', errors='coerce'
        )
        start_date = metadata_df['sample_collection_date'].min().date()
        end_date = metadata_df['sample_collection_date'].max().date()
        num_genomes = len(metadata_df)
        
        genome_info = f"using {num_genomes} number of genomes collected between {start_date} and {end_date}"
    else:
        genome_info = "genome collection information not available"

    elements = [
        Paragraph("Surveillance Report", title_style),
        Paragraph("Report Details", heading_style),
        Paragraph(f"Surveillance generated by nf-ncov-voc for lineage/clade: {lineage_clade}", normal_style),
        Paragraph(f"This report is generated on {report_date} {genome_info}", normal_style),
        Spacer(1, 12),
        Paragraph("Additional Information", heading_style),
        Paragraph(f"Organism: {organism}", normal_style),
        Paragraph(f"Reference Accession: {ref_accession}", normal_style),
        Paragraph(f"Reference Database Name: {ref_db_name}", normal_style),
    ]

    return elements


def wrap_text_in_cell(cell, style):
    if isinstance(cell, str):
        return Paragraph(cell, style)
    return cell

def generate_first_table(tsv_df, indicator_mapping_df, styles):
    """Generates the first table: Indicator Summary."""
    def get_mutations_by_category(tsv_df, categories):
        mutations_by_category = defaultdict(set)
        for category in categories.split(','):
            category = category.strip()
            mutations = tsv_df.loc[tsv_df['measured_variant_functional_effect'] == category, 'original_mutation_description']
            mutations_by_category[category].update(mutations)
        return ', '.join(sorted({m for ms in mutations_by_category.values() for m in ms}))

    first_table_data = [["Surveillance Indicator", "Functional Categories", "Mutations"]]
    for _, row in indicator_mapping_df.iterrows():
        mutations = get_mutations_by_category(tsv_df, row["Sub-categories from POKAY"])
        first_table_data.append([row["Indicator"], row["Sub-categories from POKAY"], mutations])

    wrapped_style = ParagraphStyle(
        name="Wrapped",
        parent=styles["Normal"],
        fontSize=8,
        leading=10,
        wordWrap='CJK',
        alignment=TA_LEFT
    )

    wrapped_data = [[wrap_text_in_cell(cell, wrapped_style) for cell in row] for row in first_table_data]

    first_table = Table(wrapped_data, colWidths=[2 * inch, 2.5 * inch, 4 * inch])
    first_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 0), (-1, -1), 8),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
        ('TOPPADDING', (0, 0), (-1, -1), 6),
    ]))
    description = "This table contains key indicators identified"
    return create_paginated_table(first_table_data, styles, "Table 1: Indicator Summary", description)


def generate_second_table(tsv_df, styles):
    """Generates the second table with unique mutation details."""
    columns = {
        "Mutations": "original_mutation_description",
        "Functional Category": "measured_variant_functional_effect",
        "Annotation Resource": "functional_annotation_resource",
        "Lineages": "viral_lineages",
        "Clade": "clade",
        "Sequence Depth": "dp",
        "Reference Allele": "reference_seq",
        "Alternate Allele": "variant_seq",
        "Alternate Frequency": "alternate_frequency"
    }
    
    # Filter out columns with all NaN values
    valid_columns = {k: v for k, v in columns.items() if not tsv_df[v].isna().all()}
    
    # Prepare data
    data = [list(valid_columns.keys())]  # Add headers
    
    # Create a temporary dataframe with only the columns we need
    temp_df = tsv_df.dropna(subset=["measured_variant_functional_effect"])
    temp_df = temp_df[[v for v in valid_columns.values()]]
    
    # Round the alternate_frequency to 3 decimal places
    temp_df['alternate_frequency'] = temp_df['alternate_frequency'].apply(lambda x: round(float(x), 3) if pd.notnull(x) else "N/A")
    
    # Remove duplicates
    temp_df = temp_df.drop_duplicates()
    
    # Convert dataframe to list of lists
    for _, row in temp_df.iterrows():
        data.append([row[v] for v in valid_columns.values()])

    description = "This table contains key functional impacts of mutations identified"
    return create_paginated_table(data, styles, "Table 2: Mutation Details Summary", description)

def generate_third_table(tsv_df, styles):
    """Generates the third table with functional effects, including publication year and citation."""
    columns = {
        "Mutations": "original_mutation_description",
        "Functional Category": "measured_variant_functional_effect",
        "Annotation Resource": "functional_annotation_resource",
        "Functional Effect": "variant_functional_effect_description",
        "Publication Year": "publication_year",
        "Citation": "citation",
        "URL": "url"  # We'll use this to create the hyperlink
    }
    
    data = [list(columns.keys())[:-1]]  # Add headers, excluding the URL column
    
    # Create a custom style for the hyperlink
    link_style = ParagraphStyle(
        'LinkStyle',
        parent=styles['Normal'],
        fontSize=8,
        textColor='blue'
    )

    for _, row in tsv_df.dropna(subset=["measured_variant_functional_effect"]).iterrows():
        row_data = []
        for key, col in columns.items():
            if key == "Citation":
                # Create a hyperlink for the citation using HTML-style link
                url = row.get(columns["URL"], "")
                citation_text = row.get(col, "")
                if url and citation_text:
                    link_text = f'<a href="{url}" color="blue">{citation_text}</a>'
                    paragraph = Paragraph(link_text, link_style)
                    row_data.append(paragraph)
                else:
                    row_data.append(citation_text)
            elif key == "Publication Year":
                # Convert publication year to integer and then to string
                year = row.get(col)
                if pd.notna(year):
                    year_str = str(int(year))
                else:
                    year_str = ""
                row_data.append(year_str)
            elif key != "URL":  # Skip the URL column in the final table
                row_data.append(row.get(col, ""))
        data.append(row_data)

    description = "This table contains detailed functional descriptions of each functional category"
    
    # Adjust column widths to accommodate new columns
    col_widths = [1.5*inch, 1.5*inch, 1.5*inch, 2*inch, 1*inch, 2*inch]
    
    return create_paginated_table(data, styles, "Table 3: Functional Effect Summary", description, col_widths=col_widths)

def create_paginated_table(data, styles, title, description=None, max_width=9*inch, col_widths=None):
    """Creates a table that can split across pages automatically with text wrapping."""
    
    def wrap_text(cell, width):
        if isinstance(cell, str):
            return Paragraph(cell, ParagraphStyle(
                name="Wrapped",
                parent=styles["Normal"],
                fontSize=8,
                leading=10,
                wordWrap='CJK',
                alignment=TA_LEFT
            ))
        return cell

    col_widths = col_widths or [max_width / len(data[0])] * len(data[0])
    wrapped_data = [[wrap_text(cell, col_widths[i]) for i, cell in enumerate(row)] for row in data]

    table = Table(wrapped_data, colWidths=col_widths, repeatRows=1)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 0), (-1, -1), 8),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
        ('TOPPADDING', (0, 0), (-1, -1), 6),
    ]))

    elements = []
    elements.append(Paragraph(title, styles["Heading2"]))
    if description:
        elements.append(Paragraph(description, styles["Normal"]))
    elements.append(table)
    elements.append(PageBreak())
    
    return elements

def generate_pdf(tsv_file, output_pdf, metadata_file=None, indicator_mapping=None, args=None):
    """Main function to generate the PDF with table descriptions and VirusSeq acknowledgment."""
    tsv_df = pd.read_csv(tsv_file, sep='\t', header=0)
    metadata_elements = generate_metadata_section(tsv_df, metadata_file)
    indicator_mapping_df = pd.read_csv(indicator_mapping, sep='\t', header=0)
    styles = getSampleStyleSheet()

    # Initialize PDF
    pdf = SimpleDocTemplate(output_pdf, pagesize=landscape(letter), 
                            topMargin=0.5*inch, bottomMargin=0.5*inch, 
                            leftMargin=0.5*inch, rightMargin=0.5*inch)
    elements = []

    # Add metadata section
    elements.extend(metadata_elements)
    elements.append(PageBreak())

    try:
        # Add tables
        elements.extend(generate_first_table(tsv_df, indicator_mapping_df, styles))
        elements.extend(generate_second_table(tsv_df, styles))
        elements.extend(generate_third_table(tsv_df, styles))

        # Add VirusSeq acknowledgment if args.virusseq is True
        if args and args.virusseq:
            elements.append(PageBreak())
            virusseq_style = ParagraphStyle(
                'VirusSeqAcknowledgment',
                parent=styles['Normal'],
                fontSize=8,
                leading=10,
                alignment=TA_JUSTIFY
            )
            virusseq_text = (
                "The results here are in whole or part based upon data hosted at the "
                "Canadian VirusSeq Data Portal: "
                "<a href='https://virusseq-dataportal.ca/'>https://virusseq-dataportal.ca/</a>. "
                "We wish to acknowledge the following organisations/laboratories for "
                "contributing data to the Portal: Canadian Public Health Laboratory "
                "Network (CPHLN), CanCOGGeN VirusSeq and the list of labs available at "
                "<a href='https://virusseq-dataportal.ca/acknowledgements'>"
                "https://virusseq-dataportal.ca/acknowledgements</a>."
            )
            elements.append(Paragraph(virusseq_text, virusseq_style))

        # Build PDF
        pdf.build(elements)
    except Exception as e:
        print(f"Error generating PDF: {e}")
        print("Consider reducing the amount of data or increasing the page size.")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate surveillance report PDF")
    parser.add_argument("--tsv", required=True, help="Input TSV file")
    parser.add_argument("--functions_table", required=True, help="Functions table file")
    parser.add_argument("--metadata", help="Metadata file")
    parser.add_argument("--virusseq", action="store_true", help="Include VirusSeq acknowledgment")
    parser.add_argument("--output", required=True, help="Output PDF file name")
    args = parser.parse_args()

    # Generate PDF
    generate_pdf(args.tsv, args.output, args.metadata, args.functions_table, args)